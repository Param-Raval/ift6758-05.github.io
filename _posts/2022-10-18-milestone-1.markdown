---
layout: post
title:  "Milestone 1"
date:   2022-10-18 16:00:35 -0400
categories: jekyll update
---
#  IFT6758 Batch 5 Milestone Project

## Data Acquisition 


### NHL API Usage

First, we need to understand how to download the data from the API.
Most importantly, we need the gameID, before we can request it
```
import json
import requests
def getGameData(gameID=gameID):
    endpoint = 'https://statsapi.web.nhl.com/api/v1/game/{}/feed/live/'.format(gameID)
    data = requests.get(endpoint).json()
    return data
```
### Structure of Game IDs

The first 4 digits identify the season of the game (ie. 2017 for the 2017-2018 season).<br> 
The next 2 digits give the type of game, where:<br>
    01 = preseason,<br>
    02 = regular season,<br> 
    03 = playoffs,<br>
    04 = all-star.<br> 
The final 4 digits identify the specific game number. For regular season and preseason games, this ranges from 0001 to the number of games played. (1271 for seasons with 31 teams (2017 and onwards) and 1230 for seasons with 30 teams).
For playoff games, the 2nd digit of the specific number gives the round of the playoffs, the 3rd digit specifies the matchup, and the 4th digit specifies the game (out of 7).

To construct the gameID, all we need to do is format that information, which we can then make a function for:
```
def getGameId(season, gameType,game)
    '''
    season: Represented by the year, i.e 2017 for the season 2017 - 2018

    gameType: Indicates the type of game for which you want the game ID for, where
        1 = preseason, 
        2 = regular season, 
        3 = playoffs,
        4 = all-star.

    game: Indicates the specific game number 
        For non playoff games:
            goes up from 1 to 1271 [if #teams == 31, only from 2017] or 1230 [if #teams == 30]
        Playoff games:
            let abcd be the game number where,
                b represents the round of playoffs
                c represents the matchup
                d specifies the game # out of 7
    '''
    gamePrefix = ''.join(['0'] * (4 - len(str(game))))
    return '{}0{}{}{}'.format(season, gameType, gamePrefix, game)
```

Now that we know the game ID, we can write a function that loops over the seasons and gametypes to create our dataset:
```
def getDataSet(options):
    for season in options['seasons']:
        if season < 2017:
            maxGames = 1230
        else:
            maxGames = 1271
        for game in range(1, maxGames):
            getGameData(getGameId(season, options['gameType'], game))
                    
```
We can now build the dataset by calling:
```
nhlData.getDataSet(options={
    'fromSeason': 2016,
    'toSeason': 2021,
    'gameType': 2,
    'max': 4
})
```


## Cleaning the Data

After saving all of the json data, we only need to work with a portion of it. As such, we will need to look at the parts that are interesting.

Looking at a sample game, we should probably keep track of the team ids, which are found like so:

```
game_id = game_data['gameData']['game']['pk']

# get team id for home and away teams
home_team_id = game_data['gameData']['teams']['home']['id']
away_team_id = game_data['gameData']['teams']['away']['id']

# get id for season in which game was played
game_season = game_data['gameData']['game']['season']

col_names_game_data = ['gameData/game/pk', 'gameData/teams/home/id', 'gameData/teams/away/id', 'gameData/game/season']
```

Since we care about the shots being made, we can them through the ```'livedata/plays/allplays'``` to find the shots.

Looking at each play, they looks something like this:

```
{'about': {'dateTime': '2016-10-12T23:19:59Z',
           'eventId': 8,
           'eventIdx': 9,
           'goals': {'away': 0, 'home': 0},
           'ordinalNum': '1st',
           'period': 1,
           'periodTime': '01:11',
           'periodTimeRemaining': '18:49',
           'periodType': 'REGULAR'},
 'coordinates': {'x': -77.0, 'y': 5.0},
 'players': [{'player': {'fullName': 'Mitchell Marner',
                         'id': 8478483,
                         'link': '/api/v1/people/8478483'},
              'playerType': 'Shooter'},
             {'player': {'fullName': 'Craig Anderson',
                         'id': 8467950,
                         'link': '/api/v1/people/8467950'},
              'playerType': 'Goalie'}],
 'result': {'description': 'Mitchell Marner Wrist Shot saved by Craig Anderson',
            'event': 'Shot',
            'eventCode': 'OTT8',
            'eventTypeId': 'SHOT',
            'secondaryType': 'Wrist Shot'},
 'team': {'id': 10,
          'link': '/api/v1/teams/10',
          'name': 'Toronto Maple Leafs',
          'triCode': 'TOR'}}
{'about': {'dateTime': '2016-10-12T23:29:09Z',
           'eventId': 27,
           'eventIdx': 43,
           'goals': {'away': 1, 'home': 0},
           'ordinalNum': '1st',
           'period': 1,
           'periodTime': '08:21',
           'periodTimeRemaining': '11:39',
           'periodType': 'REGULAR'},
 'coordinates': {'x': -70.0, 'y': 1.0},
 'players': [{'player': {'fullName': 'Auston Matthews',
                         'id': 8479318,
                         'link': '/api/v1/people/8479318'},
              'playerType': 'Scorer',
              'seasonTotal': 1},
             {'player': {'fullName': 'Zach Hyman',
                         'id': 8475786,
                         'link': '/api/v1/people/8475786'},
              'playerType': 'Assist',
              'seasonTotal': 1},
             {'player': {'fullName': 'William Nylander',
                         'id': 8477939,
                         'link': '/api/v1/people/8477939'},
              'playerType': 'Assist',
              'seasonTotal': 1},
             {'player': {'fullName': 'Craig Anderson',
                         'id': 8467950,
                         'link': '/api/v1/people/8467950'},
              'playerType': 'Goalie'}],
 'result': {'description': 'Auston Matthews (1) Wrist Shot, assists: Zach '
                           'Hyman (1), William Nylander (1)',
            'emptyNet': False,
            'event': 'Goal',
            'eventCode': 'OTT27',
            'eventTypeId': 'GOAL',
            'gameWinningGoal': False,
            'secondaryType': 'Wrist Shot',
            'strength': {'code': 'EVEN', 'name': 'Even'}},
 'team': {'id': 10,
          'link': '/api/v1/teams/10',
          'name': 'Toronto Maple Leafs',
          'triCode': 'TOR'}}
```

From here, we see we want the following fields for each play:

```
col_names_shots = ['about/dateTime', 'about/period', 'about/periodTime', 'about/periodType', 'coordinates', 'players', 
             'result/secondaryType', 'result/eventTypeId',
            'team/id', 'team/name', 'team/triCode']
col_names_goal = ['result/emptyNet', 'result/strength/code']
```

Since only goals will have some information, while shots that miss don't have the strength and emptyNet information.

Although strength is only there for the goals, and doesn't indicate the number of players on the ice, we can calculate this by looking at the penalties in every game. By looking at the timestamps and adding our handcrafted rulings, we can know how many players are on the ice at any given time, and hence play!

If we cared about some other features, such as turnover-goals, rebounds, shot-off-the-rush, we could look into adding some more information.

Turnovers:
- We could look at whether any goal was made after a giveaway and takeaway event was made.
Rebounds:
- We could add this by looking at whether or not the goal was made soon after a shot was made
Buzzer-beaters:
- By looking at the PERIOD-END events, we can know whether or not the shot was made close to when the buzzer was going to sound! Are teams better at scoring under the high-pressure environments?


Knowing these, we can now write a bit of code to turn the json data we downloaded into a pandas dataframe with the column names that we wanted!

|play_time|period_num          |about/periodTime|shot_type|play_type |play_team_id|play_team_name|play_team_tricode|empty_net|strength|game_id   |home_team_id|season|x       |y    |shooter_id|goalie_id|goalie_name|shooter_name  |
|---------|--------------------|----------------|---------|----------|------------|--------------|-----------------|---------|--------|----------|------------|------|--------|-----|----------|---------|-----------|--------------|
|2022-02-26T03:12:36Z|1                   |01:53           |Wrist Shot|SHOT      |26          |Los Angeles Kings|LAK              |False    |        |2021020828|24          |20212022|87.0    |26.0 |8480434.0 |8476434.0|John Gibson|Sean Durzi    |
|2022-02-26T03:13:21Z|1                   |02:38           |Tip-In   |SHOT      |26          |Los Angeles Kings|LAK              |False    |        |2021020828|24          |20212022|-80.0   |-7.0 |8481560.0 |8476434.0|John Gibson|Arthur Kaliyev|
|2022-02-26T03:13:27Z|1                   |02:44           |Wrist Shot|SHOT      |24          |Anaheim Ducks |ANA              |False    |        |2021020828|24          |20212022|50.0    |-2.0 |8475164.0 |8471734.0|Jonathan Quick|Jakob Silfverberg|
|2022-02-26T03:15:35Z|1                   |04:10           |Slap Shot|SHOT      |26          |Los Angeles Kings|LAK              |False    |        |2021020828|24          |20212022|-55.0   |24.0 |8479675.0 |8476434.0|John Gibson|Trevor Moore  |
|2022-02-26T03:15:44Z|1                   |04:19           |Wrist Shot|SHOT      |26          |Los Angeles Kings|LAK              |False    |        |2021020828|24          |20212022|-51.0   |17.0 |8479675.0 |8476434.0|John Gibson|Trevor Moore  |
|2022-02-26T03:16:57Z|1                   |05:03           |Slap Shot|SHOT      |26          |Los Angeles Kings|LAK              |False    |        |2021020828|24          |20212022|-8.0    |29.0 |8478911.0 |8476434.0|John Gibson|Matt Roy      |

Cleaning up the column names and making the data a bit more tidy (such as making the coordinate strings into floats), we get the following dataframe).


## Q2 Interactive Debugging Tool

This tool allows the user to visualise the events of the desired game. The tool makes it convenient for the user by allowing the user to scrub through the list of games and their events, with the ability to toggle between regular games / playoff games.<br>
There might be events where coordinates for the puck aren't available where visualising the event doesn't make sense, in such cases the tool prints the event data.<br>
This tool also supports playing through the list of events, where the events of the selected game are visualised in sequence at a specified interval between events.<br>

![image](/assets/images/idt1.png)

### Creating an interactive visualisation
Begin with reading the regular games dataset and the playoff games dataset into the memory, along with initialising the list of respective gameIDs for referencing the events of a particular game.

```python
# Reading the datasets
gameData = pd.read_csv('dataset.csv', index_col=0)
playoffData = pd.read_csv('playoff_game_plays.csv', index_col=0)

# Listing the game IDs for indexing the events of a particular game
gameIDs = gameData['game_id'] 
playoffGameIDs = playoffData['game_id']

baseImage = 'nhl.png' # Path of the rink image
visDf = None # Dataframe representing the events of a particular game
```

Instantiate the appropriate widget controls as required. In this instance, we are using:
-  The Play widget to automatically scrub through the events of a particular game in a specified interval.
- Two IntSlider widgets to scrub through the gameIDs and the events of a selected game, the selection is then used to index the game and the event from the dataset.
- jslink is used to establish the relationship beteween the autoplay and the slider to be linked with, in this case it is linked with the events slider.
- A checkbox to toggle between the regular games and the playoff games.
- A reference to the cell output to have granular control over it, such as capturing the output, clearing the output on demand, etcetera.
    
```python
# IPython widget control to play / pause the scrubbing of events
play = Play(
    value=0,
    min=0,
    step=1,
    interval=2000,
    description="Play",
    disabled=False
)

# IPython widget to scrub through the list of games
gameSlider = IntSlider(
    value=0,
    min=0,
    max=len(gameIDs)-1,
    step=1,
    description='Game Index:',
    disabled=False,
    continuous_update=False,
    orientation='horizontal',
    readout=True,
    readout_format='d')

# IPython widget to scrub through the events of a particular game
event = IntSlider(value=0,
                 min=0,
                 step=1,
                 description='Event Index: ',
                 disabled=False,
                continuous_update=False,
                orientation='horizontal',
                readout=True,
                readout_format='d')

isPlayoff = Checkbox(description="Is Playoff?")

jslink((play, 'value'), (event, 'value')) # Establishes the play / pause control with the event slider to automate the scrubbing of events
display(isPlayoff)
display(gameSlider, HBox([play, event])) # Display the IPython widget controls


# Configuring the widget output
out = Output() 
display(out)
```

Specify the callback functions and set the event handlers for the widget controls for making it interactive. Doing this will execute the callback function specfied for respective actions on the widget controls. In this instance:

- Scrubbing thtough the game index and selecting one will instantiate a dataframe with the events of that particular game.
- Scrubbing through the event index and selecting one will plot the puck at the specified coordinates of the event on the ice rink image.
- Toggling the isPlayoff will result in switching between the regular games and the playoff games.
    
```python
@out.capture()
def callback(gameID):
    global visDf
    visDf = gameData[gameData['game_id'] == gameIDs[gameID['new']]] # Fetching the events of a particular game

@out.capture()
def call(change):
    isPlayoff = change
    
@out.capture()
def plot_event(e):
    out.clear_output()
    try:
        # Plotting the event to visualise it
        event_ = visDf.iloc[e['new'], :]
        img = image.imread(baseImage)
        fig, ax = plt.subplots(figsize=(9,4))
        ax.imshow(img, extent=[-100, 100, 42.5, -42.5])
        plt.plot((event_['x']), (event_['y']), marker='o', color="black")
        plt.show()
    except IndexError:
        print('End of events')
    except:
        print(event_)

# Callbacks for the widget controls
gameSlider.observe(callback, names=['value'])
isPlayoff.observe(call, names=['value'])
event.observe(plot_event, names=['value'])
```

Q5


![image](/assets/images/plot1.png)

plot 1 discussion:<br>

This chart shows the ratio of makes and misses for each shot type, as well as the shot frequency.

From this chart, we see that wrist shots are by far the most common type of shot taken across the league. Wrist shots are very versatile. They are effective from a wide range of distances, are quick to execute, and very accurate, hence the high rate of utilization.

Although it's difficult to precisely discern from this visualization, it appears that the tip-in and deflected shots have the highest goal percentages, and could therefore be considered the most dangerous type of shot. However, neither of these are really a "type" of shot, per se. The former are redirections of the puck off another player's stick, and the later is the result of an unintentional deflection off a player's body. The most dangerous "true" shot type from this graph is either the backhand or snap shot.

This figure was chosen because it does a good job describing shot effectiveness as well as shot volume. Although it is simple, it demonstrates well the distribution of shot types and goals across the league.<br>

![image](/assets/images/plot2.png)

plot 2 discussion:<br>

This figure demonstrates the relationship between shot distance and shot success over successive seasons. For each season, a histogram was generated where each bin shows the number of missed shots taken (orange) and goals (cyan) between a range of distances.<br>

As we can see from the graph, the success rate of a shot climbs from a distance of 0 to about 8 or 9 feet. It then falls as distance increases. This general trend is stable over the years. 

The only glaring distinction between the graphs is the lower overall shot volume in the 2020-2021 season. However, this mostly attributable to the shortening of the season due to the Covid-19 Pandemic.

This figure was chosen because it effectively demonstrates the most and least effective distances (in terms of goal percentage) for taking shots, and how this is stable over the years.



![image](/assets/images/plot3.png)
plot 3 discussion: <br>

This plot is similar to plot two, however it shows the relationship between shot distance and goal percentage for each shot type. Each line shows how the goal percentage changes as the shot distance increases. The shots were binned by distance ranges of 5ft and the midpoints were plotted.

There is no black or white answer to the question: "What is the most dangerous type of shot". The answer, as is often the case, is: "It depends".

All of the shots are most effective at their closest range. Slap-shots and deflections stand out most in this regard, with goal percentages approaching 61 and 57 percent respectively from the range of 0-5ft. While all shots this season were most effective when taken close to the goal, only deflections and tip-ins surpass a goal percentange of 20 at a range of 20ft or greater. However, as stated previously, these are not really intentional shot types. Snap and slap shots are the most effective shots from a range of 20-40ft. After this distance, the results get harder to interpretate, as the plot is quite spiky. This is due to a lower sample size for many types of shots from longer ranges.

The exception to this is the wrist-shot. The wrist-shot is the most frequent shot type, and it sees a notable uptick in goal percentage from the distance range of 65-75ft.
